"use strict";(self.webpackChunkmoving_average_plus_docs=self.webpackChunkmoving_average_plus_docs||[]).push([[2722],{9173:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=t(4848),n=t(8453);const r={sidebar_position:6},i="\ud83d\udccf Partials Memory",o={id:"mvavg-methods/partials/partials-memory",title:"\ud83d\udccf Partials Memory",description:"By its nature, the partials don't copy the data on the original array, but instead store already computed data based on the original array. This means that a single partial instance consumes constant memory, regardless of the size of the original array.",source:"@site/docs/mvavg-methods/partials/partials-memory.md",sourceDirName:"mvavg-methods/partials",slug:"/mvavg-methods/partials/partials-memory",permalink:"/DataTomeDocs/docs/mvavg-methods/partials/partials-memory",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/mvavg-methods/partials/partials-memory.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udcc8 Partial Point Count",permalink:"/DataTomeDocs/docs/mvavg-methods/partials/partial-point-count"},next:{title:"Analysis Methods",permalink:"/DataTomeDocs/docs/category/analysis-methods"}},l={},c=[{value:"\ud83d\udcdd Syntax",id:"-syntax",level:3},{value:"\ud83d\udd2e Example",id:"-example",level:3},{value:"\u23f1 Complexity",id:"-complexity",level:3}];function d(e){const a={code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.header,{children:(0,s.jsx)(a.h1,{id:"-partials-memory",children:"\ud83d\udccf Partials Memory"})}),"\n",(0,s.jsx)(a.p,{children:"By its nature, the partials don't copy the data on the original array, but instead store already computed data based on the original array. This means that a single partial instance consumes constant memory, regardless of the size of the original array."}),"\n",(0,s.jsx)(a.p,{children:"With this in mind, don't make sense to calculate the memory usage of a single partial instance, as it will always be the same.\nInstead, the memory usage of the partials is calculated based on the number of partial instances created inside this one DataTomeMvAvg object."}),"\n",(0,s.jsx)(a.h3,{id:"-syntax",children:"\ud83d\udcdd Syntax"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-cpp",children:"size_t partials_memory();\n"})}),"\n",(0,s.jsx)(a.h3,{id:"-example",children:"\ud83d\udd2e Example"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-cpp",children:"DataTomeMvAvg<unsigned int> intAverage(10);\n\nintAverage.partial_create(3);\nintAverage.partial_create(5);\n\nintAverage.partials_memory(); // Will return 2\n"})}),"\n",(0,s.jsx)(a.h3,{id:"-complexity",children:"\u23f1 Complexity"}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Constant (O(1))"}),"."]})]})}function m(e={}){const{wrapper:a}={...(0,n.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,a,t)=>{t.d(a,{R:()=>i,x:()=>o});var s=t(6540);const n={},r=s.createContext(n);function i(e){const a=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(r.Provider,{value:a},e.children)}}}]);